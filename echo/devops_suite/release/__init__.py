"""Release phase generators"""

from typing import Tuple
from echo.devops_suite.master_suite import BaseGenerator, ScriptType


class ReleaseGenerator(BaseGenerator):
    """Generate release phase scripts"""
    
    def generate(self, task_type: str, **kwargs) -> Tuple[str, ScriptType]:
        """Generate a release script"""
        
        generators = {
            "semantic_version": self._semantic_version,
            "release_notes": self._release_notes,
            "tagging": self._tagging,
            "publishing": self._publishing,
            "rollback": self._rollback,
            "create_release": self._create_release,
        }
        
        generator_func = generators.get(task_type, self._default)
        return generator_func(**kwargs)
    
    def _semantic_version(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate semantic versioning script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Semantic Versioning Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Determine version bump type from commits
get_bump_type() {
    local commits=$(git log --format=%B $(git describe --tags --abbrev=0 2>/dev/null || echo "")..HEAD)
    
    if echo "$commits" | grep -q "BREAKING CHANGE"; then
        echo "major"
    elif echo "$commits" | grep -q "^feat"; then
        echo "minor"
    else
        echo "patch"
    fi
}

bump_type=$(get_bump_type)
log "Detected bump type: $bump_type"

# Use npm version for semver bumping
if [ -f "package.json" ]; then
    npm version "$bump_type" --no-git-tag-version
fi

log "Semantic version updated! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _release_notes(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate release notes script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Release Notes Generator
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

VERSION="${1:-$(git describe --tags --abbrev=0)}"
PREV_VERSION=$(git describe --tags --abbrev=0 "$VERSION^" 2>/dev/null || echo "")

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Generating release notes for $VERSION..."

{
    echo "# Release Notes - $VERSION"
    echo ""
    echo "## Date: $(date +%Y-%m-%d)"
    echo ""
    
    if [ -n "$PREV_VERSION" ]; then
        echo "## Changes since $PREV_VERSION"
        echo ""
        
        echo "### âœ¨ Features"
        git log "$PREV_VERSION..$VERSION" --pretty=format:"- %s" --grep="^feat" || echo "- No new features"
        echo ""
        echo ""
        
        echo "### ğŸ› Bug Fixes"
        git log "$PREV_VERSION..$VERSION" --pretty=format:"- %s" --grep="^fix" || echo "- No bug fixes"
        echo ""
        echo ""
        
        echo "### ğŸ“š Documentation"
        git log "$PREV_VERSION..$VERSION" --pretty=format:"- %s" --grep="^docs" || echo "- No documentation changes"
        echo ""
        echo ""
        
        echo "### ğŸ”§ Chores"
        git log "$PREV_VERSION..$VERSION" --pretty=format:"- %s" --grep="^chore" || echo "- No chores"
        echo ""
        echo ""
        
        echo "### Contributors"
        git log "$PREV_VERSION..$VERSION" --format='%aN' | sort -u | sed 's/^/- @/'
        echo ""
    fi
    
    echo "---"
    echo "*Generated by Echo DevOps Master Suite ğŸŒ™*"
} > "RELEASE_NOTES_$VERSION.md"

log "Release notes generated: RELEASE_NOTES_$VERSION.md ğŸŒ™"
cat "RELEASE_NOTES_$VERSION.md"
'''
        return script, ScriptType.BASH
    
    def _tagging(self, tag_name: str = "v1.0.0", **kwargs) -> Tuple[str, ScriptType]:
        """Generate git tagging script"""
        script = f'''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Git Tagging Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TAG_NAME="${{1:-{tag_name}}}"
MESSAGE="${{2:-Release $TAG_NAME}}"

log() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}}

log "Creating tag: $TAG_NAME"

# Create annotated tag
git tag -a "$TAG_NAME" -m "$MESSAGE"

log "Tag created successfully!"
log "Push with: git push origin $TAG_NAME"
log "Or push all tags: git push --tags"

log "Done! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _publishing(self, registry: str = "npm", **kwargs) -> Tuple[str, ScriptType]:
        """Generate package publishing script"""
        if registry == "pypi":
            script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PyPI Publishing Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Publishing to PyPI..."

# Install twine
pip install twine

# Build package
python -m build

# Upload to PyPI
twine upload dist/*

log "Published to PyPI! ğŸŒ™"
'''
        elif registry == "npm":
            script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# npm Publishing Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Publishing to npm..."

# Run tests
npm test

# Publish
npm publish

log "Published to npm! ğŸŒ™"
'''
        else:  # docker
            script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Docker Registry Publishing Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMAGE_NAME="${IMAGE_NAME:-myapp}"
TAG="${TAG:-latest}"
REGISTRY="${REGISTRY:-docker.io}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Publishing to $REGISTRY..."

# Tag for registry
docker tag "$IMAGE_NAME:$TAG" "$REGISTRY/$IMAGE_NAME:$TAG"

# Push
docker push "$REGISTRY/$IMAGE_NAME:$TAG"

log "Published to registry! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _rollback(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate rollback script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Release Rollback Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ROLLBACK_VERSION="${1:-}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

if [ -z "$ROLLBACK_VERSION" ]; then
    log "ERROR: Please specify rollback version"
    log "Usage: $0 <version>"
    exit 1
fi

log "Rolling back to version: $ROLLBACK_VERSION"

# Git rollback
log "Checking out version $ROLLBACK_VERSION..."
git checkout "$ROLLBACK_VERSION"

# Rebuild and redeploy
log "Rebuilding application..."
./build.sh || true

log "Redeploying application..."
./deploy.sh || true

log "Rollback complete! ğŸŒ™"
log "IMPORTANT: Verify the application is working correctly"
'''
        return script, ScriptType.BASH
    
    def _create_release(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate complete release creation script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Complete Release Creation Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

VERSION_TYPE="${1:-patch}"  # major, minor, or patch

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Creating new release..."

# 1. Bump version
log "Step 1: Bumping version ($VERSION_TYPE)..."
./scripts/bump-version.sh "$VERSION_TYPE"
NEW_VERSION=$(git describe --tags --abbrev=0)

# 2. Generate changelog
log "Step 2: Generating changelog..."
./scripts/generate-changelog.sh

# 3. Generate release notes
log "Step 3: Generating release notes..."
./scripts/generate-release-notes.sh "$NEW_VERSION"

# 4. Create git tag
log "Step 4: Creating git tag..."
git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"

# 5. Build artifacts
log "Step 5: Building artifacts..."
./scripts/build.sh

# 6. Run tests
log "Step 6: Running tests..."
./scripts/test.sh

# 7. Push to remote
log "Step 7: Pushing to remote..."
git push origin main
git push origin "$NEW_VERSION"

log "Release $NEW_VERSION created successfully! ğŸŒ™"
log "Next steps:"
log "  - Publish to package registry"
log "  - Deploy to production"
log "  - Announce release"
'''
        return script, ScriptType.BASH
    
    def _default(self, **kwargs) -> Tuple[str, ScriptType]:
        """Default release script"""
        script = '''#!/usr/bin/env bash
# Default release script
# Generated by Echo ğŸŒ™

echo "Release task - customize this script for your needs"
'''
        return script, ScriptType.BASH


__all__ = ["ReleaseGenerator"]
