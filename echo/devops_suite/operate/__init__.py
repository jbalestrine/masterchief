"""Operate phase generators"""

from typing import Tuple
from echo.devops_suite.master_suite import BaseGenerator, ScriptType


class OperateGenerator(BaseGenerator):
    """Generate operate phase scripts"""
    
    def generate(self, task_type: str, **kwargs) -> Tuple[str, ScriptType]:
        """Generate an operate script"""
        
        generators = {
            "health_checks": self._health_checks,
            "autoscaling": self._autoscaling,
            "backup": self._backup,
            "disaster_recovery": self._disaster_recovery,
            "incident_response": self._incident_response,
            "runbooks": self._runbooks,
            "on_call": self._on_call,
        }
        
        generator_func = generators.get(task_type, self._default)
        return generator_func(**kwargs)
    
    def _health_checks(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate health check script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Health Check Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SERVICE_URL="${SERVICE_URL:-http://localhost:8000}"
HEALTH_ENDPOINT="${HEALTH_ENDPOINT:-/health}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running health checks for $SERVICE_URL..."

# HTTP health check
check_http() {
    local url="$1"
    local status=$(curl -s -o /dev/null -w "%{http_code}" "$url")
    
    if [ "$status" = "200" ]; then
        log "âœ“ HTTP health check passed ($status)"
        return 0
    else
        log "âœ— HTTP health check failed ($status)"
        return 1
    fi
}

# Database connectivity check
check_database() {
    log "Checking database connectivity..."
    # Add database-specific checks
    # psql, mysql, mongo, etc.
}

# Cache connectivity check
check_cache() {
    log "Checking cache connectivity..."
    # Redis, Memcached, etc.
    if command -v redis-cli &>/dev/null; then
        redis-cli ping &>/dev/null && log "âœ“ Redis is up" || log "âœ— Redis is down"
    fi
}

# Disk space check
check_disk_space() {
    log "Checking disk space..."
    local usage=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
    
    if [ "$usage" -gt 90 ]; then
        log "âœ— Disk usage critical: ${usage}%"
        return 1
    elif [ "$usage" -gt 80 ]; then
        log "âš  Disk usage warning: ${usage}%"
    else
        log "âœ“ Disk usage OK: ${usage}%"
    fi
}

# Memory check
check_memory() {
    log "Checking memory..."
    free -m | awk 'NR==2{printf "Memory Usage: %.2f%%\\n", $3*100/$2 }'
}

# Run all checks
check_http "$SERVICE_URL$HEALTH_ENDPOINT"
check_database
check_cache
check_disk_space
check_memory

log "Health checks complete! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _autoscaling(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate autoscaling configuration script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Autoscaling Configuration Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DEPLOYMENT_NAME="${1:-myapp}"
NAMESPACE="${NAMESPACE:-default}"
MIN_REPLICAS="${MIN_REPLICAS:-2}"
MAX_REPLICAS="${MAX_REPLICAS:-10}"
CPU_THRESHOLD="${CPU_THRESHOLD:-70}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Configuring autoscaling for $DEPLOYMENT_NAME..."

# Kubernetes HPA
kubectl autoscale deployment "$DEPLOYMENT_NAME" \
    --namespace="$NAMESPACE" \
    --min="$MIN_REPLICAS" \
    --max="$MAX_REPLICAS" \
    --cpu-percent="$CPU_THRESHOLD"

log "Autoscaling configured! ğŸŒ™"
kubectl get hpa -n "$NAMESPACE"
'''
        return script, ScriptType.BASH
    
    def _backup(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate backup script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Backup Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BACKUP_DIR="${BACKUP_DIR:-/backups}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
RETENTION_DAYS="${RETENTION_DAYS:-30}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Starting backup..."

mkdir -p "$BACKUP_DIR"

# Database backup
backup_database() {
    log "Backing up database..."
    
    # PostgreSQL
    if command -v pg_dump &>/dev/null; then
        pg_dump -U postgres -d mydb > "$BACKUP_DIR/db_$TIMESTAMP.sql"
    fi
    
    # MySQL
    if command -v mysqldump &>/dev/null; then
        mysqldump -u root mydb > "$BACKUP_DIR/db_$TIMESTAMP.sql"
    fi
}

# File backup
backup_files() {
    log "Backing up files..."
    tar -czf "$BACKUP_DIR/files_$TIMESTAMP.tar.gz" /var/www /etc/app
}

# Kubernetes resources
backup_kubernetes() {
    log "Backing up Kubernetes resources..."
    kubectl get all -o yaml > "$BACKUP_DIR/k8s_$TIMESTAMP.yaml"
}

# Clean old backups
cleanup_old_backups() {
    log "Cleaning up old backups..."
    find "$BACKUP_DIR" -type f -mtime +$RETENTION_DAYS -delete
}

backup_database
backup_files
backup_kubernetes
cleanup_old_backups

log "Backup complete! ğŸŒ™"
log "Backup location: $BACKUP_DIR"
'''
        return script, ScriptType.BASH
    
    def _disaster_recovery(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate disaster recovery script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Disaster Recovery Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BACKUP_FILE="${1:-}"
TARGET_ENV="${2:-production}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

if [ -z "$BACKUP_FILE" ]; then
    log "ERROR: Please specify backup file"
    log "Usage: $0 <backup_file> [target_env]"
    exit 1
fi

log "Starting disaster recovery for $TARGET_ENV..."

# Restore database
restore_database() {
    log "Restoring database from $BACKUP_FILE..."
    
    # PostgreSQL
    if [[ "$BACKUP_FILE" == *.sql ]]; then
        psql -U postgres -d mydb < "$BACKUP_FILE"
    fi
    
    # MongoDB
    if [[ "$BACKUP_FILE" == *.bson ]]; then
        mongorestore --archive="$BACKUP_FILE"
    fi
}

# Restore files
restore_files() {
    if [[ "$BACKUP_FILE" == *.tar.gz ]]; then
        log "Restoring files from $BACKUP_FILE..."
        tar -xzf "$BACKUP_FILE" -C /
    fi
}

# Restore Kubernetes resources
restore_kubernetes() {
    if [[ "$BACKUP_FILE" == *.yaml ]]; then
        log "Restoring Kubernetes resources..."
        kubectl apply -f "$BACKUP_FILE"
    fi
}

# Run appropriate restore
case "$BACKUP_FILE" in
    *.sql|*.bson)
        restore_database
        ;;
    *.tar.gz)
        restore_files
        ;;
    *.yaml)
        restore_kubernetes
        ;;
    *)
        log "Unknown backup file format"
        exit 1
        ;;
esac

log "Disaster recovery complete! ğŸŒ™"
log "Please verify system functionality"
'''
        return script, ScriptType.BASH
    
    def _incident_response(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate incident response script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Incident Response Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SEVERITY="${1:-P2}"  # P1=Critical, P2=High, P3=Medium, P4=Low
INCIDENT_TYPE="${2:-unknown}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "INCIDENT DETECTED: $INCIDENT_TYPE (Severity: $SEVERITY)"

# Gather diagnostic information
gather_diagnostics() {
    log "Gathering diagnostic information..."
    
    mkdir -p /tmp/incident-$(date +%Y%m%d-%H%M%S)
    cd /tmp/incident-*
    
    # System info
    uname -a > system_info.txt
    df -h > disk_usage.txt
    free -m > memory_usage.txt
    top -bn1 > process_list.txt
    
    # Application logs
    kubectl logs -n production --tail=1000 > app_logs.txt 2>&1 || true
    
    # Network info
    netstat -tulpn > network_connections.txt 2>&1 || true
}

# Alert on-call team
alert_team() {
    log "Alerting on-call team..."
    
    # PagerDuty, Slack, etc.
    if command -v curl &>/dev/null; then
        curl -X POST https://events.pagerduty.com/v2/enqueue \
            -H 'Content-Type: application/json' \
            -d "{\"routing_key\":\"YOUR_KEY\",\"event_action\":\"trigger\",\"payload\":{\"summary\":\"$INCIDENT_TYPE\",\"severity\":\"$SEVERITY\"}}"
    fi
}

# Execute mitigation steps
mitigate() {
    log "Executing mitigation steps..."
    
    case "$INCIDENT_TYPE" in
        "high_cpu")
            log "Scaling up resources..."
            kubectl scale deployment myapp --replicas=10
            ;;
        "database_down")
            log "Attempting database restart..."
            kubectl rollout restart statefulset/database
            ;;
        "high_error_rate")
            log "Rolling back to previous version..."
            kubectl rollout undo deployment/myapp
            ;;
    esac
}

gather_diagnostics
alert_team
mitigate

log "Incident response initiated! ğŸŒ™"
log "Follow incident runbook for complete resolution"
'''
        return script, ScriptType.BASH
    
    def _runbooks(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate runbook template"""
        script = '''# Runbook Template
# Generated by Echo ğŸŒ™

## Incident: [INCIDENT NAME]

### Severity: [P1/P2/P3/P4]

### Description
Brief description of the incident type and symptoms.

### Detection
How this incident is typically detected:
- [ ] Monitoring alert
- [ ] User report
- [ ] Health check failure

### Impact
- **Users Affected**: [Number/Percentage]
- **Services Affected**: [List services]
- **Business Impact**: [High/Medium/Low]

### Triage Steps
1. Verify the incident is occurring
2. Assess severity and impact
3. Alert appropriate team members
4. Gather diagnostic information

### Investigation
```bash
# Check application logs
kubectl logs -n production deployment/myapp --tail=100

# Check system resources
kubectl top pods -n production

# Check recent deployments
kubectl rollout history deployment/myapp -n production
```

### Resolution Steps
1. **Immediate Mitigation**:
   - [ ] Step 1
   - [ ] Step 2

2. **Root Cause Fix**:
   - [ ] Step 1
   - [ ] Step 2

3. **Verification**:
   - [ ] Confirm service is healthy
   - [ ] Check error rates
   - [ ] Verify user functionality

### Rollback Procedure
```bash
# Rollback to previous version
kubectl rollout undo deployment/myapp -n production
kubectl rollout status deployment/myapp -n production
```

### Communication
- **Internal**: [Slack channel, email list]
- **External**: [Status page, support tickets]

### Post-Incident
- [ ] Update incident log
- [ ] Schedule post-mortem
- [ ] Create follow-up tasks
- [ ] Update runbook with learnings

### Related Runbooks
- [Link to related runbook 1]
- [Link to related runbook 2]

---
*Generated by Echo DevOps Master Suite ğŸŒ™*
'''
        return script, ScriptType.YAML
    
    def _on_call(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate on-call management script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# On-Call Management Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ACTION="${1:-current}"  # current, schedule, swap

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

case "$ACTION" in
    current)
        log "Current on-call engineer:"
        # PagerDuty API call or local file
        ;;
    schedule)
        log "On-call schedule:"
        # Display next 7 days of on-call schedule
        ;;
    swap)
        log "Swapping on-call assignment..."
        # Swap on-call between engineers
        ;;
    *)
        echo "Usage: $0 {current|schedule|swap}"
        exit 1
        ;;
esac

log "Done! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _default(self, **kwargs) -> Tuple[str, ScriptType]:
        """Default operate script"""
        script = '''#!/usr/bin/env bash
# Default operate script
# Generated by Echo ğŸŒ™

echo "Operate task - customize this script for your needs"
'''
        return script, ScriptType.BASH


__all__ = ["OperateGenerator"]
