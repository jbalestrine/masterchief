"""Code phase generators"""

from typing import Tuple
from echo.devops_suite.master_suite import BaseGenerator, ScriptType


class CodeGenerator(BaseGenerator):
    """Generate code phase scripts"""
    
    def generate(self, task_type: str, **kwargs) -> Tuple[str, ScriptType]:
        """Generate a code script"""
        
        generators = {
            "repo_scaffold": self._repo_scaffold,
            "branch_management": self._branch_management,
            "pre_commit": self._pre_commit,
            "linting": self._linting,
            "code_review": self._code_review,
            "dependencies": self._dependencies,
            "secret_scan": self._secret_scan,
        }
        
        generator_func = generators.get(task_type, self._default)
        return generator_func(**kwargs)
    
    def _repo_scaffold(self, repo_name: str = "myrepo", language: str = "python", **kwargs) -> Tuple[str, ScriptType]:
        """Generate repository scaffolding script"""
        script = f'''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Repository Scaffolding Script
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

REPO_NAME="{repo_name}"
LANGUAGE="{language}"

log() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}}

log "Scaffolding repository: $REPO_NAME ($LANGUAGE)"

# Create directory structure
mkdir -p "$REPO_NAME"/{{src,tests,docs,.github/workflows}}

cd "$REPO_NAME"

# Initialize Git
git init

# Create .gitignore
cat > .gitignore << 'EOF'
# Language-specific
__pycache__/
*.py[cod]
*$py.class
node_modules/
*.o
*.so
.DS_Store

# IDE
.vscode/
.idea/
*.swp
*.swo

# Environment
.env
.venv/
venv/
EOF

# Create README
cat > README.md << 'EOF'
# $REPO_NAME

## Description
TODO: Add description

## Getting Started
TODO: Add setup instructions

## Contributing
TODO: Add contribution guidelines

## License
MIT

*Generated by Echo DevOps Master Suite ðŸŒ™*
EOF

# Create LICENSE
cat > LICENSE << 'EOF'
MIT License

Copyright (c) $(date +%Y)

Permission is hereby granted, free of charge, to any person obtaining a copy...
EOF

# Create CONTRIBUTING.md
cat > CONTRIBUTING.md << 'EOF'
# Contributing Guide

## How to Contribute
1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Submit a pull request

## Code Style
- Follow language-specific best practices
- Write tests for new features
- Update documentation

*Generated by Echo DevOps Master Suite ðŸŒ™*
EOF

log "Repository scaffolded successfully! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _branch_management(self, strategy: str = "gitflow", **kwargs) -> Tuple[str, ScriptType]:
        """Generate branch management script"""
        script = f'''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Branch Management Script ({strategy})
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STRATEGY="{strategy}"

log() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}}

# GitFlow branch creation
create_feature_branch() {{
    local feature_name=$1
    log "Creating feature branch: feature/$feature_name"
    git checkout develop
    git pull origin develop
    git checkout -b "feature/$feature_name"
}}

create_release_branch() {{
    local version=$1
    log "Creating release branch: release/$version"
    git checkout develop
    git pull origin develop
    git checkout -b "release/$version"
}}

create_hotfix_branch() {{
    local version=$1
    log "Creating hotfix branch: hotfix/$version"
    git checkout main
    git pull origin main
    git checkout -b "hotfix/$version"
}}

finish_feature() {{
    local branch=$(git branch --show-current)
    log "Finishing feature branch: $branch"
    git checkout develop
    git merge --no-ff "$branch"
    git branch -d "$branch"
}}

# Command router
case "${{1:-help}}" in
    feature)
        create_feature_branch "$2"
        ;;
    release)
        create_release_branch "$2"
        ;;
    hotfix)
        create_hotfix_branch "$2"
        ;;
    finish)
        finish_feature
        ;;
    *)
        echo "Usage: $0 {{feature|release|hotfix|finish}} [name/version]"
        exit 1
        ;;
esac

log "Done! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _pre_commit(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate pre-commit hooks configuration"""
        script = '''# Pre-commit hooks configuration
# Generated by Echo ðŸŒ™
# 
# Install: pip install pre-commit
# Setup: pre-commit install

repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-json
      - id: check-added-large-files
        args: ['--maxkb=1000']
      - id: check-merge-conflict
      - id: detect-private-key
      - id: mixed-line-ending

  - repo: https://github.com/psf/black
    rev: 23.12.1
    hooks:
      - id: black
        language_version: python3.10

  - repo: https://github.com/pycqa/flake8
    rev: 7.0.0
    hooks:
      - id: flake8
        args: ['--max-line-length=88', '--extend-ignore=E203']

  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
        args: ['--profile', 'black']

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.8.0
    hooks:
      - id: mypy
        additional_dependencies: [types-all]

  - repo: https://github.com/gitleaks/gitleaks
    rev: v8.18.1
    hooks:
      - id: gitleaks

# Generated by Echo DevOps Master Suite ðŸŒ™
'''
        return script, ScriptType.YAML
    
    def _linting(self, language: str = "python", **kwargs) -> Tuple[str, ScriptType]:
        """Generate linting script"""
        if language == "python":
            script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Python Linting Script
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running Python linters..."

# Black - code formatting
log "Running Black..."
black --check --diff .

# isort - import sorting
log "Running isort..."
isort --check-only --diff .

# flake8 - style guide
log "Running flake8..."
flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
flake8 . --count --max-complexity=10 --max-line-length=88 --statistics

# mypy - type checking
log "Running mypy..."
mypy .

# pylint - code analysis
log "Running pylint..."
pylint **/*.py

log "All linting checks passed! ðŸŒ™"
'''
        else:
            script = f'''#!/usr/bin/env bash
# Linting script for {language}
# Generated by Echo ðŸŒ™

echo "Linting {language} code..."
# Add language-specific linting commands here
'''
        return script, ScriptType.BASH
    
    def _code_review(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate code review checklist"""
        script = '''# Code Review Checklist
# Generated by Echo ðŸŒ™

## General
- [ ] Code follows project style guidelines
- [ ] Code is self-documenting and/or well-commented
- [ ] No unnecessary complexity
- [ ] No code duplication (DRY principle)
- [ ] Naming is clear and consistent

## Functionality
- [ ] Changes meet requirements/acceptance criteria
- [ ] Edge cases are handled
- [ ] Error handling is appropriate
- [ ] No obvious bugs

## Testing
- [ ] Unit tests added/updated
- [ ] Integration tests added/updated (if applicable)
- [ ] Tests pass locally
- [ ] Code coverage maintained or improved

## Security
- [ ] No hardcoded secrets or credentials
- [ ] Input validation implemented
- [ ] Authentication/authorization checks present
- [ ] No SQL injection vulnerabilities
- [ ] No XSS vulnerabilities

## Performance
- [ ] No obvious performance issues
- [ ] Database queries optimized
- [ ] Caching considered where appropriate
- [ ] No memory leaks

## Documentation
- [ ] README updated (if needed)
- [ ] API documentation updated (if needed)
- [ ] CHANGELOG updated
- [ ] Comments explain "why" not "what"

## Dependencies
- [ ] New dependencies justified
- [ ] Dependency versions pinned
- [ ] No vulnerable dependencies

## CI/CD
- [ ] CI pipeline passes
- [ ] Build successful
- [ ] All tests pass

---
*Generated by Echo DevOps Master Suite*
'''
        return script, ScriptType.YAML
    
    def _dependencies(self, language: str = "python", **kwargs) -> Tuple[str, ScriptType]:
        """Generate dependency management script"""
        if language == "python":
            script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Python Dependency Management
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Update dependencies
update_deps() {
    log "Updating dependencies..."
    pip list --outdated --format=json | \
        python3 -c "import json, sys; print('\\n'.join([p['name'] for p in json.load(sys.stdin)]))" | \
        xargs -n1 pip install -U
}

# Check for vulnerabilities
check_vulnerabilities() {
    log "Checking for vulnerabilities..."
    pip install safety
    safety check --json
}

# Generate requirements.txt
freeze_deps() {
    log "Freezing dependencies..."
    pip freeze > requirements.txt
}

# Audit dependencies
audit_deps() {
    log "Auditing dependencies..."
    pip-audit
}

case "${1:-help}" in
    update)
        update_deps
        ;;
    check)
        check_vulnerabilities
        ;;
    freeze)
        freeze_deps
        ;;
    audit)
        audit_deps
        ;;
    *)
        echo "Usage: $0 {update|check|freeze|audit}"
        exit 1
        ;;
esac

log "Done! ðŸŒ™"
'''
        else:
            script = f'''#!/usr/bin/env bash
# Dependency management for {language}
# Generated by Echo ðŸŒ™

echo "Managing {language} dependencies..."
'''
        return script, ScriptType.BASH
    
    def _secret_scan(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate secret scanning script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Secret Scanning Script
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Scanning for secrets and credentials..."

# Check if gitleaks is installed
if ! command -v gitleaks &> /dev/null; then
    log "Installing gitleaks..."
    # Install gitleaks
    if [[ "$OSTYPE" == "darwin"* ]]; then
        brew install gitleaks
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        wget https://github.com/gitleaks/gitleaks/releases/download/v8.18.1/gitleaks_8.18.1_linux_x64.tar.gz
        tar -xzf gitleaks_8.18.1_linux_x64.tar.gz
        sudo mv gitleaks /usr/local/bin/
    fi
fi

# Run gitleaks
log "Running gitleaks scan..."
gitleaks detect --source . --report-format json --report-path gitleaks-report.json

if [ $? -eq 0 ]; then
    log "âœ“ No secrets found! ðŸŒ™"
else
    log "âœ— Secrets detected! Check gitleaks-report.json"
    exit 1
fi

# Additional patterns to check
log "Checking for common secret patterns..."

# AWS keys
if grep -r "AKIA[0-9A-Z]{16}" . --exclude-dir={.git,node_modules,venv}; then
    log "âœ— Potential AWS access key found!"
    exit 1
fi

# Private keys
if grep -r "BEGIN.*PRIVATE KEY" . --exclude-dir={.git,node_modules,venv}; then
    log "âœ— Potential private key found!"
    exit 1
fi

# Generic passwords
if grep -ri "password\s*=\s*['\"][^'\"]{1,}" . --exclude-dir={.git,node_modules,venv}; then
    log "âœ— Potential hardcoded password found!"
    exit 1
fi

log "All secret scans passed! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _default(self, **kwargs) -> Tuple[str, ScriptType]:
        """Default code script"""
        script = '''#!/usr/bin/env bash
# Default code script
# Generated by Echo ðŸŒ™

echo "Code task - customize this script for your needs"
'''
        return script, ScriptType.BASH


__all__ = ["CodeGenerator"]
