"""Test phase generators"""

from typing import Tuple
from echo.devops_suite.master_suite import BaseGenerator, ScriptType


class TestGenerator(BaseGenerator):
    """Generate test phase scripts"""
    
    def generate(self, task_type: str, **kwargs) -> Tuple[str, ScriptType]:
        """Generate a test script"""
        
        generators = {
            "unit_tests": self._unit_tests,
            "integration_tests": self._integration_tests,
            "e2e_tests": self._e2e_tests,
            "performance_tests": self._performance_tests,
            "load_tests": self._load_tests,
            "security_tests": self._security_tests,
            "chaos_tests": self._chaos_tests,
            "coverage": self._coverage,
        }
        
        generator_func = generators.get(task_type, self._default)
        return generator_func(**kwargs)
    
    def _unit_tests(self, language: str = "python", **kwargs) -> Tuple[str, ScriptType]:
        """Generate unit test script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Unit Test Runner
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running unit tests..."

# Python
if [ -f "pytest.ini" ] || [ -f "setup.py" ]; then
    log "Running Python unit tests..."
    pytest tests/unit/ -v --tb=short
fi

# Node.js
if [ -f "package.json" ]; then
    log "Running Node.js unit tests..."
    npm test
fi

# Go
if [ -f "go.mod" ]; then
    log "Running Go unit tests..."
    go test -v ./... -short
fi

log "Unit tests complete! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _integration_tests(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate integration test script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Integration Test Runner
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running integration tests..."

# Start test dependencies (e.g., database, redis)
start_dependencies() {
    if [ -f "docker-compose.test.yml" ]; then
        log "Starting test dependencies..."
        docker-compose -f docker-compose.test.yml up -d
        sleep 5  # Wait for services to be ready
    fi
}

# Stop test dependencies
stop_dependencies() {
    if [ -f "docker-compose.test.yml" ]; then
        log "Stopping test dependencies..."
        docker-compose -f docker-compose.test.yml down
    fi
}

# Cleanup on exit
trap stop_dependencies EXIT

start_dependencies

# Run integration tests
pytest tests/integration/ -v --tb=short

log "Integration tests complete! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _e2e_tests(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate E2E test script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# End-to-End Test Runner
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running E2E tests..."

# Install Playwright if needed
if [ ! -d "node_modules/playwright" ]; then
    log "Installing Playwright..."
    npm install -D @playwright/test
    npx playwright install
fi

# Run E2E tests
npx playwright test

log "E2E tests complete! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _performance_tests(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate performance test script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Performance Test Runner
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TARGET_URL="${TARGET_URL:-http://localhost:8000}"
DURATION="${DURATION:-30s}"
VUS="${VUS:-10}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running performance tests against $TARGET_URL..."

# Install k6 if needed
if ! command -v k6 &> /dev/null; then
    log "Installing k6..."
    if [[ "$OSTYPE" == "darwin"* ]]; then
        brew install k6
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        sudo apt-get update
        sudo apt-get install -y k6
    fi
fi

# Create basic k6 test script
cat > /tmp/perf-test.js << 'EOF'
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
    vus: __ENV.VUS || 10,
    duration: __ENV.DURATION || '30s',
};

export default function () {
    const res = http.get(__ENV.TARGET_URL || 'http://localhost:8000');
    check(res, {
        'status is 200': (r) => r.status === 200,
        'response time < 500ms': (r) => r.timings.duration < 500,
    });
    sleep(1);
}
EOF

# Run k6
k6 run /tmp/perf-test.js

log "Performance tests complete! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _load_tests(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate load test script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Load Test Runner
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TARGET_URL="${TARGET_URL:-http://localhost:8000}"
USERS="${USERS:-100}"
RAMP_TIME="${RAMP_TIME:-60}"
DURATION="${DURATION:-300}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running load tests..."
log "Target: $TARGET_URL"
log "Users: $USERS"
log "Ramp time: ${RAMP_TIME}s"
log "Duration: ${DURATION}s"

# Use locust for load testing
cat > /tmp/locustfile.py << 'EOF'
from locust import HttpUser, task, between

class LoadTestUser(HttpUser):
    wait_time = between(1, 3)
    
    @task
    def index(self):
        self.client.get("/")
    
    @task(3)
    def api_endpoint(self):
        self.client.get("/api/health")
EOF

# Install locust
pip install locust

# Run locust
locust -f /tmp/locustfile.py \
    --host="$TARGET_URL" \
    --users="$USERS" \
    --spawn-rate=10 \
    --run-time="${DURATION}s" \
    --headless

log "Load tests complete! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _security_tests(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate security test script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Security Test Runner (SAST + DAST)
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running security tests..."

# SAST - Static Application Security Testing
log "Running SAST with Bandit (Python)..."
pip install bandit
bandit -r . -f json -o bandit-report.json || true

# SAST - Semgrep
log "Running Semgrep..."
pip install semgrep
semgrep --config=auto . --json -o semgrep-report.json || true

# Dependency scanning
log "Running dependency vulnerability scan..."
pip install safety
safety check --json > safety-report.json || true

# DAST - Dynamic Application Security Testing (with OWASP ZAP)
if command -v docker &> /dev/null; then
    log "Running DAST with OWASP ZAP..."
    TARGET_URL="${TARGET_URL:-http://localhost:8000}"
    
    docker run --rm -v $(pwd):/zap/wrk:rw \
        owasp/zap2docker-stable \
        zap-baseline.py -t "$TARGET_URL" -J zap-report.json || true
fi

log "Security tests complete! ðŸŒ™"
log "Reports: bandit-report.json, semgrep-report.json, safety-report.json, zap-report.json"
'''
        return script, ScriptType.BASH
    
    def _chaos_tests(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate chaos engineering test script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Chaos Engineering Tests
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running chaos engineering tests..."

# Install chaos-mesh CLI
if ! command -v chaosd &> /dev/null; then
    log "Installing chaosd..."
    curl -fsSL https://mirrors.chaos-mesh.org/chaosd-latest.sh | bash
fi

# Network delay chaos
test_network_delay() {
    log "Testing network delay..."
    chaosd attack network delay \
        --duration 30s \
        --latency 100ms \
        --interface eth0
}

# CPU stress chaos
test_cpu_stress() {
    log "Testing CPU stress..."
    chaosd attack stress cpu \
        --duration 30s \
        --workers 2 \
        --load 80
}

# Memory stress chaos
test_memory_stress() {
    log "Testing memory stress..."
    chaosd attack stress mem \
        --duration 30s \
        --size 512MB
}

# Run chaos experiments
log "Starting chaos experiments..."
test_network_delay
sleep 5
test_cpu_stress
sleep 5
test_memory_stress

log "Chaos tests complete! ðŸŒ™"
log "Monitor your application's resilience during these tests"
'''
        return script, ScriptType.BASH
    
    def _coverage(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate test coverage script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Test Coverage Reporter
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MIN_COVERAGE="${MIN_COVERAGE:-80}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running test coverage analysis..."

# Python coverage
if [ -f "pytest.ini" ] || [ -f "setup.py" ]; then
    log "Running Python coverage..."
    pip install pytest-cov
    pytest --cov=. --cov-report=html --cov-report=term --cov-report=xml \
        --cov-fail-under="$MIN_COVERAGE"
    log "Coverage report: htmlcov/index.html"
fi

# JavaScript coverage
if [ -f "package.json" ]; then
    log "Running JavaScript coverage..."
    npm test -- --coverage --coverageReporters=html --coverageReporters=text
    log "Coverage report: coverage/index.html"
fi

# Go coverage
if [ -f "go.mod" ]; then
    log "Running Go coverage..."
    go test -v -coverprofile=coverage.out ./...
    go tool cover -html=coverage.out -o coverage.html
    log "Coverage report: coverage.html"
fi

log "Coverage analysis complete! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _default(self, **kwargs) -> Tuple[str, ScriptType]:
        """Default test script"""
        script = '''#!/usr/bin/env bash
# Default test script
# Generated by Echo ðŸŒ™

echo "Test task - customize this script for your needs"
'''
        return script, ScriptType.BASH


__all__ = ["TestGenerator"]
