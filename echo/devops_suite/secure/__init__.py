"""Secure phase generators"""

from typing import Tuple
from echo.devops_suite.master_suite import BaseGenerator, ScriptType


class SecureGenerator(BaseGenerator):
    """Generate secure phase scripts"""
    
    def generate(self, task_type: str, **kwargs) -> Tuple[str, ScriptType]:
        """Generate a security script"""
        
        generators = {
            "vulnerability_scan": self._vulnerability_scan,
            "container_scan": self._container_scan,
            "compliance": self._compliance,
            "access_control": self._access_control,
            "certificates": self._certificates,
            "secret_rotation": self._secret_rotation,
            "network_policies": self._network_policies,
        }
        
        generator_func = generators.get(task_type, self._default)
        return generator_func(**kwargs)
    
    def _vulnerability_scan(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate vulnerability scanning script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Vulnerability Scanning Script
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running vulnerability scans..."

# Trivy - Multi-purpose scanner
if command -v trivy &>/dev/null; then
    log "Scanning with Trivy..."
    trivy fs --severity HIGH,CRITICAL . -o trivy-report.json
else
    log "Installing Trivy..."
    curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
    trivy fs --severity HIGH,CRITICAL . -o trivy-report.json
fi

# Grype - Vulnerability scanner
if command -v grype &>/dev/null; then
    log "Scanning with Grype..."
    grype . -o json > grype-report.json
fi

# OWASP Dependency Check
if command -v dependency-check &>/dev/null; then
    log "Running OWASP Dependency Check..."
    dependency-check --scan . --format JSON --out dependency-check-report.json
fi

log "Vulnerability scans complete! ðŸŒ™"
log "Reports: trivy-report.json, grype-report.json"
'''
        return script, ScriptType.BASH
    
    def _container_scan(self, image_name: str = "myapp:latest", **kwargs) -> Tuple[str, ScriptType]:
        """Generate container security scanning script"""
        script = f'''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Container Security Scanning Script
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMAGE_NAME="{image_name}"

log() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}}

log "Scanning container image: $IMAGE_NAME"

# Trivy image scan
log "Running Trivy image scan..."
trivy image --severity HIGH,CRITICAL "$IMAGE_NAME" -o trivy-image-report.json

# Grype image scan
log "Running Grype image scan..."
grype "$IMAGE_NAME" -o json > grype-image-report.json

# Anchore scan
if command -v anchore-cli &>/dev/null; then
    log "Running Anchore scan..."
    anchore-cli image add "$IMAGE_NAME"
    anchore-cli image wait "$IMAGE_NAME"
    anchore-cli image vuln "$IMAGE_NAME" all
fi

# Snyk container scan
if command -v snyk &>/dev/null; then
    log "Running Snyk container scan..."
    snyk container test "$IMAGE_NAME" --json-file-output=snyk-container-report.json
fi

log "Container scans complete! ðŸŒ™"
log "Reports: trivy-image-report.json, grype-image-report.json"
'''
        return script, ScriptType.BASH
    
    def _compliance(self, framework: str = "CIS", **kwargs) -> Tuple[str, ScriptType]:
        """Generate compliance checking script"""
        script = f'''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Compliance Checking Script ({framework})
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FRAMEWORK="{framework}"

log() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}}

log "Running $FRAMEWORK compliance checks..."

# CIS Kubernetes Benchmark
if [ "$FRAMEWORK" = "CIS" ]; then
    log "Running kube-bench for CIS Kubernetes Benchmark..."
    kubectl apply -f https://raw.githubusercontent.com/aquasecurity/kube-bench/main/job.yaml
    sleep 10
    kubectl logs -f job/kube-bench
fi

# HIPAA compliance
if [ "$FRAMEWORK" = "HIPAA" ]; then
    log "Checking HIPAA compliance..."
    # Add HIPAA-specific checks
fi

# SOC2 compliance
if [ "$FRAMEWORK" = "SOC2" ]; then
    log "Checking SOC2 compliance..."
    # Add SOC2-specific checks
fi

# PCI-DSS compliance
if [ "$FRAMEWORK" = "PCI" ]; then
    log "Checking PCI-DSS compliance..."
    # Add PCI-specific checks
fi

# Open Policy Agent (OPA) policies
if command -v opa &>/dev/null; then
    log "Running OPA policy checks..."
    opa test policies/ -v
fi

log "Compliance checks complete! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _access_control(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate RBAC configuration"""
        script = '''# Kubernetes RBAC Configuration
# Generated by Echo ðŸŒ™

apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-service-account
  namespace: production
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: app-role
  namespace: production
rules:
  - apiGroups: [""]
    resources: ["pods", "services", "configmaps", "secrets"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["apps"]
    resources: ["deployments", "replicasets"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: app-role-binding
  namespace: production
subjects:
  - kind: ServiceAccount
    name: app-service-account
    namespace: production
roleRef:
  kind: Role
  name: app-role
  apiGroup: rbac.authorization.k8s.io
---
# ClusterRole for cluster-wide permissions
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: read-only-cluster-role
rules:
  - apiGroups: [""]
    resources: ["nodes", "namespaces"]
    verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: read-only-binding
subjects:
  - kind: ServiceAccount
    name: app-service-account
    namespace: production
roleRef:
  kind: ClusterRole
  name: read-only-cluster-role
  apiGroup: rbac.authorization.k8s.io

# Generated by Echo DevOps Master Suite ðŸŒ™
'''
        return script, ScriptType.YAML
    
    def _certificates(self, domain: str = "example.com", **kwargs) -> Tuple[str, ScriptType]:
        """Generate certificate management script"""
        script = f'''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Certificate Management Script
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DOMAIN="{domain}"
CERT_DIR="/etc/ssl/certs"

log() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}}

# Generate self-signed certificate
generate_self_signed() {{
    log "Generating self-signed certificate for $DOMAIN..."
    openssl req -x509 -nodes -days 365 -newkey rsa:2048 \\
        -keyout "$CERT_DIR/$DOMAIN.key" \\
        -out "$CERT_DIR/$DOMAIN.crt" \\
        -subj "/CN=$DOMAIN"
}}

# Request Let's Encrypt certificate
request_letsencrypt() {{
    log "Requesting Let's Encrypt certificate for $DOMAIN..."
    if command -v certbot &>/dev/null; then
        certbot certonly --standalone -d "$DOMAIN" --non-interactive --agree-tos -m admin@$DOMAIN
    else
        log "Installing certbot..."
        apt-get update && apt-get install -y certbot
        certbot certonly --standalone -d "$DOMAIN" --non-interactive --agree-tos -m admin@$DOMAIN
    fi
}}

# Renew certificates
renew_certificates() {{
    log "Renewing certificates..."
    certbot renew --quiet
}}

# Check certificate expiration
check_expiration() {{
    log "Checking certificate expiration..."
    local cert_file="$CERT_DIR/$DOMAIN.crt"
    
    if [ -f "$cert_file" ]; then
        local expiry=$(openssl x509 -enddate -noout -in "$cert_file" | cut -d= -f2)
        log "Certificate expires: $expiry"
    fi
}}

# Install certificate in Kubernetes
install_k8s_cert() {{
    log "Installing certificate in Kubernetes..."
    kubectl create secret tls "$DOMAIN-tls" \\
        --cert="$CERT_DIR/$DOMAIN.crt" \\
        --key="$CERT_DIR/$DOMAIN.key" \\
        --dry-run=client -o yaml | kubectl apply -f -
}}

case "${{1:-generate}}" in
    generate)
        generate_self_signed
        ;;
    letsencrypt)
        request_letsencrypt
        ;;
    renew)
        renew_certificates
        ;;
    check)
        check_expiration
        ;;
    k8s)
        install_k8s_cert
        ;;
    *)
        echo "Usage: $0 {{generate|letsencrypt|renew|check|k8s}}"
        exit 1
        ;;
esac

log "Done! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _secret_rotation(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate secret rotation script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Secret Rotation Script
# Generated by Echo for Marsh ðŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SECRET_TYPE="${1:-database}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Rotating $SECRET_TYPE secrets..."

# Generate new password
generate_password() {
    openssl rand -base64 32
}

# Rotate database password
rotate_database_secret() {
    log "Rotating database password..."
    
    local new_password=$(generate_password)
    
    # Update password in database
    # mysql -e "ALTER USER 'app'@'%' IDENTIFIED BY '$new_password';"
    
    # Update Kubernetes secret
    kubectl create secret generic db-credentials \
        --from-literal=password="$new_password" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    # Restart application to pick up new secret
    kubectl rollout restart deployment/myapp
}

# Rotate API keys
rotate_api_keys() {
    log "Rotating API keys..."
    
    local new_key=$(generate_password)
    
    # Update in Kubernetes
    kubectl create secret generic api-keys \
        --from-literal=api-key="$new_key" \
        --dry-run=client -o yaml | kubectl apply -f -
}

# Rotate TLS certificates
rotate_tls_certs() {
    log "Rotating TLS certificates..."
    
    # Generate new certificate
    ./scripts/generate-cert.sh
    
    # Update Kubernetes secret
    kubectl create secret tls tls-cert \
        --cert=new-cert.crt \
        --key=new-cert.key \
        --dry-run=client -o yaml | kubectl apply -f -
}

case "$SECRET_TYPE" in
    database)
        rotate_database_secret
        ;;
    api-key)
        rotate_api_keys
        ;;
    tls)
        rotate_tls_certs
        ;;
    *)
        echo "Usage: $0 {database|api-key|tls}"
        exit 1
        ;;
esac

log "Secret rotation complete! ðŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _network_policies(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate network policy configuration"""
        script = '''# Kubernetes Network Policies
# Generated by Echo ðŸŒ™

# Default deny all ingress and egress
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: production
spec:
  podSelector: {}
  policyTypes:
    - Ingress
    - Egress
---
# Allow ingress from specific namespaces
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-ingress
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
    - Ingress
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx
      ports:
        - protocol: TCP
          port: 8080
---
# Allow egress to database
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-to-database
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
    - Egress
  egress:
    - to:
      - podSelector:
          matchLabels:
            app: database
      ports:
        - protocol: TCP
          port: 5432
---
# Allow DNS resolution
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: production
spec:
  podSelector: {}
  policyTypes:
    - Egress
  egress:
    - to:
      - namespaceSelector:
          matchLabels:
            name: kube-system
      ports:
        - protocol: UDP
          port: 53
---
# Allow egress to external services
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-external-egress
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
    - Egress
  egress:
    - to:
      - ipBlock:
          cidr: 0.0.0.0/0
          except:
            - 169.254.169.254/32  # Block metadata service
      ports:
        - protocol: TCP
          port: 443

# Generated by Echo DevOps Master Suite ðŸŒ™
'''
        return script, ScriptType.YAML
    
    def _default(self, **kwargs) -> Tuple[str, ScriptType]:
        """Default security script"""
        script = '''#!/usr/bin/env bash
# Default security script
# Generated by Echo ðŸŒ™

echo "Security task - customize this script for your needs"
'''
        return script, ScriptType.BASH


__all__ = ["SecureGenerator"]
