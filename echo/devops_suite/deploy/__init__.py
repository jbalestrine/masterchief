"""Deploy phase generators"""

from typing import Tuple
from echo.devops_suite.master_suite import BaseGenerator, ScriptType


class DeployGenerator(BaseGenerator):
    """Generate deploy phase scripts"""
    
    def generate(self, task_type: str, **kwargs) -> Tuple[str, ScriptType]:
        """Generate a deploy script"""
        
        generators = {
            "terraform": self._terraform,
            "pulumi": self._pulumi,
            "cloudformation": self._cloudformation,
            "kubernetes": self._kubernetes,
            "helm": self._helm,
            "kustomize": self._kustomize,
            "blue_green": self._blue_green,
            "canary": self._canary,
            "rolling": self._rolling,
            "database_migration": self._database_migration,
            "serverless": self._serverless,
            "config_management": self._config_management,
            "feature_flags": self._feature_flags,
        }
        
        generator_func = generators.get(task_type, self._default)
        return generator_func(**kwargs)
    
    def _terraform(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate Terraform deployment script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Terraform Deployment Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ENV="${1:-dev}"
ACTION="${2:-plan}"  # plan or apply

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Terraform deployment for environment: $ENV"

# Initialize
log "Initializing Terraform..."
terraform init -backend-config="env/$ENV/backend.tf"

# Validate
log "Validating configuration..."
terraform validate

# Plan
log "Planning changes..."
terraform plan -var-file="env/$ENV/terraform.tfvars" -out=tfplan

if [ "$ACTION" == "apply" ]; then
    log "Applying changes..."
    terraform apply tfplan
    
    log "Deployment complete! ğŸŒ™"
else
    log "Plan complete! Review tfplan and run with 'apply' to execute ğŸŒ™"
fi
'''
        return script, ScriptType.BASH
    
    def _pulumi(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate Pulumi deployment script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Pulumi Deployment Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STACK="${1:-dev}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Pulumi deployment for stack: $STACK"

# Select stack
pulumi stack select "$STACK"

# Preview
log "Previewing changes..."
pulumi preview

# Deploy
log "Deploying..."
pulumi up --yes

log "Deployment complete! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _cloudformation(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate CloudFormation deployment script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CloudFormation Deployment Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STACK_NAME="${1:-my-stack}"
TEMPLATE_FILE="${2:-template.yaml}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "CloudFormation deployment for stack: $STACK_NAME"

# Validate template
log "Validating template..."
aws cloudformation validate-template --template-body "file://$TEMPLATE_FILE"

# Check if stack exists
if aws cloudformation describe-stacks --stack-name "$STACK_NAME" &>/dev/null; then
    log "Updating existing stack..."
    aws cloudformation update-stack \
        --stack-name "$STACK_NAME" \
        --template-body "file://$TEMPLATE_FILE" \
        --capabilities CAPABILITY_IAM
    
    aws cloudformation wait stack-update-complete --stack-name "$STACK_NAME"
else
    log "Creating new stack..."
    aws cloudformation create-stack \
        --stack-name "$STACK_NAME" \
        --template-body "file://$TEMPLATE_FILE" \
        --capabilities CAPABILITY_IAM
    
    aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME"
fi

log "Deployment complete! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _kubernetes(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate Kubernetes deployment script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Kubernetes Deployment Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NAMESPACE="${1:-default}"
MANIFEST_DIR="${2:-k8s/}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Deploying to Kubernetes namespace: $NAMESPACE"

# Create namespace if it doesn't exist
kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

# Apply manifests
log "Applying manifests..."
kubectl apply -f "$MANIFEST_DIR" -n "$NAMESPACE"

# Wait for rollout
log "Waiting for deployments to complete..."
kubectl rollout status deployment -n "$NAMESPACE"

log "Deployment complete! ğŸŒ™"
log "Resources:"
kubectl get all -n "$NAMESPACE"
'''
        return script, ScriptType.BASH
    
    def _helm(self, release_name: str = "myapp", chart: str = "./chart", **kwargs) -> Tuple[str, ScriptType]:
        """Generate Helm deployment script"""
        script = f'''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Helm Deployment Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RELEASE_NAME="{release_name}"
CHART="{chart}"
NAMESPACE="${{NAMESPACE:-default}}"
VALUES_FILE="${{VALUES_FILE:-values.yaml}}"

log() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}}

log "Deploying Helm chart: $CHART"

# Update dependencies
log "Updating chart dependencies..."
helm dependency update "$CHART"

# Lint chart
log "Linting chart..."
helm lint "$CHART"

# Deploy or upgrade
log "Installing/upgrading release: $RELEASE_NAME"
helm upgrade --install "$RELEASE_NAME" "$CHART" \\
    --namespace "$NAMESPACE" \\
    --create-namespace \\
    --values "$VALUES_FILE" \\
    --wait \\
    --timeout 5m

log "Deployment complete! ğŸŒ™"
helm status "$RELEASE_NAME" -n "$NAMESPACE"
'''
        return script, ScriptType.BASH
    
    def _kustomize(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate Kustomize deployment script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Kustomize Deployment Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OVERLAY="${1:-dev}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Deploying with Kustomize overlay: $OVERLAY"

# Build and apply
log "Building and applying manifests..."
kubectl apply -k "overlays/$OVERLAY"

log "Deployment complete! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _blue_green(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate blue-green deployment script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Blue-Green Deployment Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NEW_VERSION="${1:-}"
NAMESPACE="${NAMESPACE:-default}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

if [ -z "$NEW_VERSION" ]; then
    log "ERROR: Please specify new version"
    exit 1
fi

log "Starting blue-green deployment for version: $NEW_VERSION"

# Deploy green (new version)
log "Deploying green environment..."
kubectl apply -f k8s/deployment-green.yaml -n "$NAMESPACE"
kubectl set image deployment/myapp-green myapp="myapp:$NEW_VERSION" -n "$NAMESPACE"

# Wait for green to be ready
log "Waiting for green deployment..."
kubectl rollout status deployment/myapp-green -n "$NAMESPACE"

# Run smoke tests
log "Running smoke tests on green..."
# Add smoke tests here

# Switch traffic to green
log "Switching traffic to green..."
kubectl patch service myapp -p '{"spec":{"selector":{"version":"green"}}}' -n "$NAMESPACE"

log "Blue-green deployment complete! ğŸŒ™"
log "Old blue deployment can be removed when confident"
'''
        return script, ScriptType.BASH
    
    def _canary(self, traffic_percent: int = 10, **kwargs) -> Tuple[str, ScriptType]:
        """Generate canary deployment script"""
        script = f'''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Canary Deployment Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NEW_VERSION="${{1:-}}"
TRAFFIC_PERCENT={traffic_percent}
NAMESPACE="${{NAMESPACE:-default}}"

log() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}}

if [ -z "$NEW_VERSION" ]; then
    log "ERROR: Please specify new version"
    exit 1
fi

log "Starting canary deployment for version: $NEW_VERSION"

# Deploy canary
log "Deploying canary with $TRAFFIC_PERCENT% traffic..."
kubectl apply -f k8s/deployment-canary.yaml -n "$NAMESPACE"
kubectl set image deployment/myapp-canary myapp="myapp:$NEW_VERSION" -n "$NAMESPACE"

# Configure traffic split (requires service mesh like Istio)
cat <<EOF | kubectl apply -f -
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: myapp
  namespace: $NAMESPACE
spec:
  hosts:
  - myapp
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        host: myapp-stable
      weight: $((100 - TRAFFIC_PERCENT))
    - destination:
        host: myapp-canary
      weight: $TRAFFIC_PERCENT
EOF

log "Canary deployment complete! ğŸŒ™"
log "Monitor metrics and gradually increase traffic if healthy"
'''
        return script, ScriptType.BASH
    
    def _rolling(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate rolling deployment script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Rolling Deployment Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NEW_VERSION="${1:-}"
NAMESPACE="${NAMESPACE:-default}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

if [ -z "$NEW_VERSION" ]; then
    log "ERROR: Please specify new version"
    exit 1
fi

log "Starting rolling deployment for version: $NEW_VERSION"

# Update deployment
log "Updating deployment..."
kubectl set image deployment/myapp myapp="myapp:$NEW_VERSION" -n "$NAMESPACE"

# Watch rollout
log "Watching rollout..."
kubectl rollout status deployment/myapp -n "$NAMESPACE"

# Verify deployment
log "Verifying deployment..."
kubectl get pods -n "$NAMESPACE" -l app=myapp

log "Rolling deployment complete! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _database_migration(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate database migration script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Database Migration Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ENV="${1:-dev}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Running database migrations for environment: $ENV"

# Backup database first
log "Creating database backup..."
./scripts/backup-database.sh

# Run migrations
if [ -f "alembic.ini" ]; then
    log "Running Alembic migrations..."
    alembic upgrade head
elif [ -f "manage.py" ]; then
    log "Running Django migrations..."
    python manage.py migrate
elif [ -f "knexfile.js" ]; then
    log "Running Knex migrations..."
    npx knex migrate:latest
else
    log "No migration tool detected"
fi

log "Database migrations complete! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _serverless(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate serverless deployment script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Serverless Deployment Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STAGE="${1:-dev}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Deploying serverless functions to stage: $STAGE"

# Deploy with Serverless Framework
if [ -f "serverless.yml" ]; then
    log "Deploying with Serverless Framework..."
    serverless deploy --stage "$STAGE"
# Deploy with AWS SAM
elif [ -f "template.yaml" ]; then
    log "Deploying with AWS SAM..."
    sam build
    sam deploy --stack-name "myapp-$STAGE"
# Deploy with Terraform
elif [ -f "main.tf" ]; then
    log "Deploying with Terraform..."
    terraform apply -var="stage=$STAGE"
fi

log "Serverless deployment complete! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _config_management(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate configuration management script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Configuration Management Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ENV="${1:-dev}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "Managing configuration for environment: $ENV"

# Update ConfigMaps in Kubernetes
if command -v kubectl &>/dev/null; then
    log "Updating Kubernetes ConfigMaps..."
    kubectl create configmap app-config \
        --from-file="config/$ENV/" \
        --dry-run=client -o yaml | kubectl apply -f -
fi

# Update SSM Parameters in AWS
if command -v aws &>/dev/null; then
    log "Updating AWS SSM Parameters..."
    while IFS== read -r key value; do
        aws ssm put-parameter \
            --name "/$ENV/$key" \
            --value "$value" \
            --type String \
            --overwrite
    done < "config/$ENV/parameters.txt"
fi

log "Configuration management complete! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _feature_flags(self, **kwargs) -> Tuple[str, ScriptType]:
        """Generate feature flag management script"""
        script = '''#!/usr/bin/env bash
set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Feature Flag Management Script
# Generated by Echo for Marsh ğŸŒ™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ACTION="${1:-list}"  # list, enable, disable
FLAG_NAME="${2:-}"
ENV="${3:-prod}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

case "$ACTION" in
    list)
        log "Listing feature flags for $ENV..."
        # Add your feature flag provider commands here
        # LaunchDarkly, Split.io, etc.
        ;;
    enable)
        log "Enabling feature flag: $FLAG_NAME in $ENV"
        # Add enable command here
        ;;
    disable)
        log "Disabling feature flag: $FLAG_NAME in $ENV"
        # Add disable command here
        ;;
    *)
        echo "Usage: $0 {list|enable|disable} [flag_name] [env]"
        exit 1
        ;;
esac

log "Done! ğŸŒ™"
'''
        return script, ScriptType.BASH
    
    def _default(self, **kwargs) -> Tuple[str, ScriptType]:
        """Default deploy script"""
        script = '''#!/usr/bin/env bash
# Default deploy script
# Generated by Echo ğŸŒ™

echo "Deploy task - customize this script for your needs"
'''
        return script, ScriptType.BASH


__all__ = ["DeployGenerator"]
